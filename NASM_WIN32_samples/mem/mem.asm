global _main
extern _printf
extern _scanf
extern _malloc
extern _free
extern _getch

BITS 32

segment .stack
stack times 1000 db 0

segment .data
N dd 0
A dd 0

hello_msg db "программа ввода массива A[] с клавиатуры и вывода его на экран",13,10,0

mess_N db "N= ",0
fmt_N db "%d",0

segment .code
_main:
   push ebp
   mov ebp,esp
;===========================
;вывод сообщения о назначении программы
   push dword hello_msg
   call _printf

;ввод N
   push dword mess_N
   call _printf

   push dword N
   push dword fmt_N
   call _scanf
;---------------------------
;подсчет размера памяти, необходимой для хранения массива eax=[N]*4+4
   mov dword eax,[N] ;рассчитываем объем памяти,
   mov dword ebx,4   ;необходимой для хранения N
   mul ebx           ;4-байтовых чисел
   add eax,4         ;запасные 4 байта т.к. отсчет индексов будет с 1, а не с 0
;---------------------------
;собственно выделение памяти для массива [A]=malloc(eax)
   push dword eax ;загружаем в стек размер требуемой памяти
   call _malloc    ;вызываем функцию динамического выделения памяти
   add esp,4      ;восстанавливаем стек
   mov dword [A],eax ;сохраняем адрес начала выделенного блока памяти в [A]
;---------------------------
;ввод массива с клавиатуры input_array(N,A)
   push dword [A] ;загружаем адрес начала массива
   push dword [N] ;загружаем число элементов массива
   call input_array ;вводим массив с клавиатуры
   add esp,8      ;восстанавливаем стек
;---------------------------
;вывод массива на экран print_array(N,A)
   push dword [A] ;загружаем адрес начала массива
   push dword [N] ;загружаем число элементов массива
   call print_array ;выводим массив на экран
   add esp,8      ;восстанавливаем стек
;---------------------------
;отдаем выделенную динамически память free(A)
   push dword [A] ;загружаем адрес начала когда-то выделенной памяти
   call _free      ;вызываем функцию высвобождения памяти
   add esp,4      ;восстанавливаем стек
;---------------------------   
   call _getch ;задержка
;---------------------------   
   mov esp,ebp
   pop ebp
ret


;---------------------------
;вывод элементов массива на экран
;---------------------------
;ebp+8 --- N число элементов массива
;ebp+12  --- A указатель на начало массива
;ebp-4  --- локальная переменная i
;---------------------------
print_array:
   push ebp
   mov ebp,esp
   sub esp,4
;---------------------------
   mov ecx,0 ;загрузка регистра счетчика по переменной i
.L_i:
   inc ecx           ;увеличиваем счетчик на 1
   mov dword [ebp-4],ecx ;сохраняем счетчик i перед итерацией цикла
;---------------------------
   mov dword ebx,[ebp+12] ;загружаем в регистр БАЗЫ адрес начала массива
   mov dword edi,[ebp-4] ;загружаем в индексный регистр номер элемента
;выводим i-й элемент массива A на экран
   push dword [ebx+edi*4] ;механизм смешанной адресации
   push dword [ebp-4]
   push dword .elem_A
   call _printf
   add esp,8 ;так как оператор printf выполняется в цикле, esp восстанавливаем
;---------------------------
   mov dword ecx,[ebp-4] ;восстанавливаем счетчик i
   cmp ecx,[ebp+8]  ;сравниваем его с предельным значением
   jl short .L_i     ;в случае необходимости повторяем цикл

;стандартный выход из подпрограммы
   mov esp,ebp
   pop ebp
ret
.elem_A db "A[%d]=%4d  ",0 ;форматирующая строка вывода элемента массива
;размещение .elem_A в сегменте кода вообще говоря нехорошо (плохой стиль)
;но не приведет к фатальным последствиям, т.к. используется только для чтения


;---------------------------
;Ввод элементов массива с клавиатуры
;---------------------------
;ebp+8  --- N число элементов массива
;ebp+12 --- A указатель на начало массива
;ebp-4  --- локальная переменная i
;---------------------------
input_array:
   push ebp
   mov ebp,esp
   sub esp,4
;---------------------------
   mov ecx,0 ;загрузка регистра счетчика по переменной i
.L_i:
   inc ecx           ;увеличиваем счетчик на 1
   mov dword [ebp-4],ecx ;сохраняем счетчик i перед итерацией цикла

;выводим приглашение к вводу A[i]
   push dword ecx
   push dword .mess_A 
   call _printf
   add esp,8 ;так как оператор printf выполняется в цикле, esp восстанавливаем

;рассчитываем смещение от начала массива по формуле eax=4*[i]+[A]
   mov dword ebx,[ebp+12] ;загружаем в регистр БАЗЫ адрес начала массива
   mov dword edi,[ebp-4] ;загружаем в индексный регистр номер элемента
   lea dword eax,[ebx+edi*4] ;загружаем в eax адрес i-го элемента массива
;собственно ввод элемента массива
   push dword eax
   push dword .fmt_A
   call _scanf
   add esp,8 ;так как оператор scanf выполняется в цикле, esp восстанавливаем
;---------------------------
   mov dword ecx,[ebp-4] ;восстанавливаем счетчик i
   cmp ecx,[ebp+8]       ;сравниваем его с предельным значением
   jl short .L_i     ;в случае необходимости повторяем цикл
;---------------------------
;стандартный выход из подпрограммы
   mov esp,ebp
   pop ebp
ret
.mess_A db "A[%d]= ",0
.fmt_A db "%d",0
;размещение .mess_A и .fmt_A в сегменте кода вообще говоря нехорошо (плохой стиль)
;но не приведет к фатальным последствиям, т.к. используется только для чтения
;---------------------------
